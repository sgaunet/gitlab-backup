# Code Patterns & Best Practices

## 1. Clean Architecture with Interface-Driven Design

**Pattern**: Strict separation between layers using interfaces for dependency injection. External dependencies (GitLab SDK, AWS SDK) are wrapped with custom interfaces.

**Why**: Enables testability, extensibility, and loose coupling. Makes it easy to swap implementations (e.g., local storage → S3).

**Examples**:

`pkg/gitlab/client_interface.go:18-29` - GitLabClient interface with 7 service interfaces:
```go
type GitLabClient interface {
    Groups() GroupsService
    Projects() ProjectsService
    ProjectImportExport() ProjectImportExportService
    Labels() LabelsService
    Issues() IssuesService
    Commits() CommitsService
    SetBaseURL(string) error
}
```

`pkg/storage/storage.go:8-11` - Storage interface:
```go
type Storage interface {
    SaveFile(ctx context.Context, archivePath string, destPath string) error
    Get(ctx context.Context, sourcePath string, destPath string) error
}
```

`pkg/app/app.go:30-35` - Dependency injection via constructor:
```go
func NewApp(config *config.Config, gitlabClient gitlab.GitLabClient, storage storage.Storage) *App {
    return &App{
        config:       config,
        gitlabClient: gitlabClient,
        storage:      storage,
    }
}
```

**Testing benefit**: Easy to inject mocks generated by moq.

## 2. Go-Idiomatic Testing with Multiple Strategies

**Pattern**: Comprehensive testing using `_test.go` suffix with three strategies:
1. **White-box tests** (`package gitlab`) - Access private functions
2. **Black-box tests** (`package gitlab_test`) - Test public API
3. **Integration tests** (`tests/integration/`) - End-to-end with testcontainers

**Why**: White-box for internal logic, black-box for API contracts, integration for real-world scenarios.

**Examples**:

`pkg/gitlab/gitlab_whitebox_test.go:1` - White-box:
```go
package gitlab  // Same package - access private functions

func TestRateLimiterInitialization(t *testing.T) {
    // Can access private fields like rateLimitDownloadAPI
    service := &Service{...}
    assert.NotNil(t, service.rateLimitDownloadAPI)
}
```

`pkg/gitlab/gitlab_blackbox_test.go:1` - Black-box:
```go
package gitlab_test  // Different package - public API only

func TestNewService(t *testing.T) {
    service, err := gitlab.NewService(cfg, mockClient)
    require.NoError(t, err)
}
```

`tests/integration/restore_local_test.go` - Integration:
```go
func TestRestoreLocal(t *testing.T) {
    // Uses testcontainers for GitLab instance
    ctx := context.Background()
    gitlabContainer, err := startGitLabContainer(ctx)
    require.NoError(t, err)
    defer gitlabContainer.Terminate(ctx)

    // End-to-end restore test
    err = app.Restore(ctx)
    assert.NoError(t, err)
}
```

**Mock generation**: `pkg/gitlab/client_interface.go:9-16` - go:generate directives:
```go
//go:generate moq -out mocks/groups_service.go -pkg mocks . GroupsService
//go:generate moq -out mocks/projects_service.go -pkg mocks . ProjectsService
```

Run with: `go generate ./...`

## 3. Sentinel Error Pattern with Error Wrapping

**Pattern**: Exported error variables (sentinel errors) for known error types, combined with `fmt.Errorf("%w")` for error wrapping.

**Why**:
- Enables `errors.Is()` checks for error type detection
- Preserves error chains for debugging
- Type-safe error handling without string matching

**Examples**:

`pkg/gitlab/error.go:10-15` - Sentinel errors:
```go
var (
    ErrUnmarshalJSON = errors.New("failed to unmarshal JSON response")
    ErrGitlabAPI     = errors.New("GitLab API error")
    ErrExportTimeout = errors.New("export timeout")
    ErrImportTimeout = errors.New("import timeout")
)
```

`pkg/gitlab/error.go:24-30` - Error wrapping:
```go
func handleAPIError(resp *http.Response) error {
    body, _ := io.ReadAll(resp.Body)
    if err := json.Unmarshal(body, &errMsg); err != nil {
        return fmt.Errorf("%w: %w", ErrUnmarshalJSON, err)  // Wraps both errors
    }
    return fmt.Errorf("%w: %s", ErrGitlabAPI, errMsg.Message)
}
```

**Usage** - Checking error types:
```go
if errors.Is(err, gitlab.ErrExportTimeout) {
    // Handle timeout specifically
} else if errors.Is(err, gitlab.ErrGitlabAPI) {
    // Handle API error
}
```

**More sentinel errors**:
- `pkg/storage/archive.go:13-20` - Storage errors (ErrArchiveInvalid, ErrPathTraversal)
- `pkg/app/restore/restore.go` - Restore errors (ErrProjectHasContent)
- `pkg/gitlab/restore.go:20-24` - Import errors

## 4. Rate Limiting with golang.org/x/time/rate and Concurrency with errgroup

**Pattern**:
- Token bucket rate limiting per API endpoint
- Structured concurrency with `errgroup.Group`
- Mutex for thread-safe configuration updates

**Why**:
- Prevents GitLab API throttling (different limits per endpoint)
- Proper error propagation with errgroup
- Thread-safe concurrent operations

**Examples**:

`pkg/gitlab/gitlab.go:25-39` - Rate limit constants:
```go
const (
    downloadRequestsPerMinute = 5  // GitLab repository files API
    exportRequestsPerMinute   = 6  // GitLab import/export API
    importRequestsPerMinute   = 6
)

const (
    rateLimitDownloadAPI = downloadRequestsPerMinute / 60.0
    rateLimitExportAPI   = exportRequestsPerMinute / 60.0
    rateLimitImportAPI   = importRequestsPerMinute / 60.0
)
```

`pkg/gitlab/gitlab.go:56-64` - Service with rate limiters:
```go
type Service struct {
    client               GitLabClient
    cfg                  *config.Config
    rateLimitDownloadAPI *rate.Limiter
    rateLimitExportAPI   *rate.Limiter
    rateLimitImportAPI   *rate.Limiter
    mu                   sync.RWMutex
}
```

`pkg/gitlab/project.go:113` - Rate limit enforcement:
```go
if err := s.rateLimitExportAPI.Wait(ctx); err != nil {
    return fmt.Errorf("rate limit wait failed: %w", err)
}
// Proceed with API call
```

`pkg/app/app.go:111-129` - Concurrent exports with errgroup:
```go
g, ctx := errgroup.WithContext(ctx)
for _, projectID := range projectIDs {
    projectID := projectID  // Capture for closure
    g.Go(func() error {
        return a.exportProject(ctx, projectID)
    })
}
if err := g.Wait(); err != nil {  // Wait for all goroutines
    return fmt.Errorf("export failed: %w", err)
}
```

**Benefits**:
- First error cancels remaining goroutines (via context)
- Respects rate limits automatically
- Clean error handling

## 5. Monorepo Structure with Dual-Binary Architecture

**Pattern**: Single repository with `pkg/`-based modular organization containing two independent CLI tools sharing common packages.

**Why**:
- Code reuse (shared GitLab client, storage, config)
- Consistent versioning
- Single test suite
- No duplication of interfaces/logic

**Examples**:

`cmd/gitlab-backup/gitlab-backup.go:1` - Backup CLI entrypoint
`cmd/gitlab-restore/gitlab-restore.go:1` - Restore CLI entrypoint

**Shared packages**:
- `pkg/gitlab/` - GitLab API client (used by both)
- `pkg/storage/` - Storage abstraction (local/S3)
- `pkg/config/` - Configuration management
- `pkg/app/` - Backup orchestration
- `pkg/app/restore/` - Restore orchestration (restore-specific)

**No database/ORM**: API-driven architecture, stateless operations.

## Additional Patterns

### Constructor Pattern
Always use constructors for complex structs:
```go
func NewService(cfg *config.Config, client GitLabClient) (*Service, error) {
    // Validate inputs
    // Initialize rate limiters
    // Return initialized struct
}
```

### Context Propagation
Always pass `context.Context` as first parameter:
```go
func (s *Service) ExportProject(ctx context.Context, projectID int) error {
    // Respect context cancellation
    // Pass to downstream calls
}
```

### Defer for Cleanup
Use defer for guaranteed cleanup:
```go
func (r *Restore) Run(ctx context.Context) error {
    tempDir, err := os.MkdirTemp("", "restore-*")
    if err != nil {
        return err
    }
    defer os.RemoveAll(tempDir)  // Always cleanup

    // Rest of function
}
```

### Table-Driven Tests
Use table-driven tests for multiple scenarios:
```go
func TestValidateProjectPath(t *testing.T) {
    tests := []struct {
        name    string
        path    string
        wantErr bool
    }{
        {"valid path", "my-project", false},
        {"invalid chars", "my/project", true},
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := ValidateProjectPath(tt.path)
            if (err != nil) != tt.wantErr {
                t.Errorf("got error %v, wantErr %v", err, tt.wantErr)
            }
        })
    }
}
```

## Anti-Patterns to Avoid

❌ **Don't**: Ignore context cancellation
```go
func (s *Service) LongOperation(ctx context.Context) error {
    // BAD: No context checks during long loop
    for i := 0; i < 10000; i++ {
        doWork()
    }
}
```

✅ **Do**: Check context periodically
```go
func (s *Service) LongOperation(ctx context.Context) error {
    for i := 0; i < 10000; i++ {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
            doWork()
        }
    }
}
```

❌ **Don't**: Use string matching for errors
```go
if strings.Contains(err.Error(), "timeout") { ... }
```

✅ **Do**: Use sentinel errors with errors.Is()
```go
if errors.Is(err, gitlab.ErrExportTimeout) { ... }
```

❌ **Don't**: Create interfaces in implementation packages just for mocking
✅ **Do**: Create interfaces where they're consumed (dependency inversion)
